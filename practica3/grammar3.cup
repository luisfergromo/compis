
package Practica3;
import java_cup.runtime.*;
import Interfaz.IOInterfaz;

parser code {:
    
    
    public void report_error(String message, Object info) {
   
        StringBuilder m = new StringBuilder("Error");
   
         if (info instanceof java_cup.runtime.Symbol) {
            
            java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);
   
             if (s.left >= 0) {                
                  m.append(" in line "+(s.left+1));   
               	 
               	  if (s.right >= 0)                    
                 	 m.append(", column "+(s.right+1));
            }
        }
   
        m.append(" : "+message);
   
        System.err.println(m);
    }
   
    
    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
        System.exit(1);
    }
:};


/* ------------Declaration of Terminals and Non Terminals Section----------- */

terminal           		ASSIGN, SEMI, DOTS, OPEN, CLOSE, PTR, INTEGER, REAL;
terminal           		oprel, oparit;

terminal String   		integer_num;
terminal String   		real_num;
terminal String   		id;
terminal String   		array, of, IF, then, WHILE, DO, mod;

non terminal String     P, D, T, S, C, E;
non terminal String     basic, compound;

/* -------------Precedence and Associatively of Terminals Section----------- */
      
precedence left oprel, oparit, ASSIGN, SEMI, DOTS, PTR, mod;

/* ----------------------------Grammar Section-------------------- */

P 		::=		D SEMI S:S1 {:if(!S1.contentEquals("Void")) System.out.println("SEMANTICS ARE INVALID "+S1); else System.out.println("\n\n============\nSEMANTICS ARE VALID");:}
			;

D 		::=		D SEMI D
			|	id:name DOTS T:type {: if(!symTable.insert_id ( name , type.toString() )) System.out.println("ERROR: identificador duplicado"); :}
			;

T 		::=		basic:t 			{:RESULT=t;:}
			|	compound:t 			{:RESULT=t;:}
			;

basic 	::=		INTEGER				{: RESULT="Integer"; :}
			|	REAL				{: RESULT="Real"; :}
			;
	
compound ::=	array OPEN integer_num CLOSE of basic:type 		{: RESULT= "Array("+type+")"; 	:}
			|	PTR basic:type									{: RESULT= "Pointer("+type+")";		:}
			;

S 		::=		S:S1 SEMI S:S2								{: if(S1.contentEquals(S2)) RESULT= "Void"; else RESULT="Error";:}
			|	id:name OPEN integer_num CLOSE ASSIGN E:E1	{:  if(symTable.get_id(name,true)==null) RESULT= "Error";
																else {
																	String tmp = symTable.get_id(name,true).type;
																	if(tmp.endsWith(E1+")")) RESULT= "Void";
																	else if(tmp.contentEquals("Array(Real)") && E1.contentEquals("Integer")) RESULT= "Void";
																	else RESULT="Error";
																}
															:}
															
			|	id:name ASSIGN E:E1							{: if(symTable.get_id(name,true)==null) RESULT= "Error";
																else {
																	String tmp = symTable.get_id(name,true).type;
																	if(tmp.contentEquals(E1)) RESULT= "Void";
																	else if(tmp.contentEquals("Real") && E1.contentEquals("Integer")) RESULT= "Void";
																	else RESULT="Error";
																}
															:}
															
			|	IF C:C1 then S:S1							{: if (C1.contentEquals("Boolean") && !S1.contentEquals("Error")) RESULT= "Void"; else RESULT="Error"; :}
			|	WHILE C:C1 DO S:S1							{: if (C1.contentEquals("Boolean") && !S1.contentEquals("Error")) RESULT= "Void"; else RESULT="Error"; :}
			;

C		::=		E:E1 oprel E:E2			{: if(E1.contentEquals(E2)) RESULT="Boolean"; else RESULT="Error"; :}
			;

E		::=		integer_num				{: RESULT="Integer"; :}
			|	real_num				{: RESULT="Real"; :}
			|	E:E1 mod E:E2			{: if(E1.contentEquals("Integer") && E2.contentEquals("Integer")) RESULT="Integer"; else RESULT="Error"; :}
			|	E:E1 OPEN E:E2 CLOSE	{: if(E2.contentEquals("Integer")) RESULT=E1; else RESULT="Error"; :}	
			|	E:E1 PTR				{: if(E1.startsWith("Pointer")) RESULT=E1; else RESULT="Error"; :}
			|	id:name					{: try{RESULT=symTable.get_id(name,true).type;}catch(Exception ex){RESULT="Error";}:}
			|	E oparit E
			;
